/*
 * generated by Xtext
 */
package org.xtext.rollercoaster.dsl.validation

import org.xtext.rollercoaster.dsl.coaster.RollerCoaster
import org.eclipse.xtext.validation.Check
import org.xtext.rollercoaster.dsl.coaster.Track
import org.xtext.rollercoaster.dsl.coaster.CoasterPackage

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class CoasterValidator extends AbstractCoasterValidator {

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

@Check
def checkCompletePath(RollerCoaster rc){
	var totalAngle = 0;
	for(Track t: rc.track){
		if(t.angle != null){
			if(t.angle.sign != null){
				totalAngle = totalAngle - t.angle.value;
			}
			else{
				totalAngle = totalAngle+t.angle.value;
			}
		}
	}
	if(totalAngle%360 != 0){
		error("Track angles do not form a cycle! "+totalAngle%360+" degrees from a cycle.", CoasterPackage.Literals.ROLLER_COASTER.getEStructuralFeature("track"));
	}
	println("totalAngle = "+totalAngle);
}

@Check
def checkStartMeetsEnd(RollerCoaster rc){
	var distance = 0.0;
	var currentX = 0.0;
	var currentY = 0.0;
	var currentAngle = 0.0;
	for(Track t: rc.track){
		if(t.angle != null){
			var angle = t.angle.value
			if(t.angle.sign != null){
				angle = angle * -1;
			}
			currentX = (currentX + Math.cos(currentAngle+angle)*t.length).floatValue.intValue;//need to check pos negative
			currentY = (currentY + Math.sin(currentAngle+angle)*t.length).floatValue.intValue;//need to check pos negative
			currentAngle = currentAngle+angle;//need to check pos negative
		}
		else{
			currentX = (currentX + Math.cos(currentAngle)*t.length).floatValue.intValue;//need to check pos negative
			currentY = (currentY + Math.sin(currentAngle)*t.length).floatValue.intValue;//need to check pos negative
			
		}
	}
	distance = Math.sqrt(Math.pow(currentX, 2) + Math.pow(currentY, 2));
	
	if(currentAngle%360 != 0 || distance != 0){
		error("End of Track does not meet start! End of track is"+distance+"m from the start.", CoasterPackage.Literals.ROLLER_COASTER.getEStructuralFeature("track"));
	}
}
	
	
	
}


