/*
 * generated by Xtext
 */
package org.xtext.rollercoaster.dsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.xtext.rollercoaster.dsl.coaster.RollerCoaster
import java.util.Date
import org.eclipse.emf.ecore.EObject
import org.xtext.rollercoaster.dsl.coaster.Straight
import org.xtext.rollercoaster.dsl.coaster.Corner

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class CoasterGenerator implements IGenerator {
	
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
	
	  	// Generate a example java file
	  	//fsa.generateFile("Track" + ".java", compile(resource.allContents.toIterable.filter(Track)))
		
		// Generate a text file report
		fsa.generateFile("RollerCoasterReport" + ".html", genReport(resource.allContents.toIterable.filter(RollerCoaster).head));

	}
	
	
	/**
	 * Generate an html report of the coasters stats
	 * For starting off this is going to include the 
	 * 	Max Speed
	 * 	Cost
	 * 	Fun
	 * 	Name
	 */	
	def genReport (RollerCoaster rc)
	
		'''
		<html>
			<body>
				<h1>Roller Coaster report for the « rc.name » roller coaster on the  « new Date() »</h1>
				<p>Number of Pieces of track 	: « rc.track.length »</p>
				<p>Number of Carts 			: « rc.cart.length»</p>
				
				<h1> Rendering of the track </h1>
  				« getPathForTrack (rc.track)»
			</body>
		</html>	
		'''

	/**
	 * Build a svg path from a list of tracks
	 */
	def getPathForTrack (Iterable <EObject> tracks){
		// The start of the svg
		val start = '''<svg width="800px" height="600px" version="1.1" xmlns="http://www.w3.org/2000/svg"> '''
		val pathStart = '''<path d=" M 400 300 '''
		
		var path = "";
		
		// Track the current angle of the track as it changes 
		var currentAngle = 0.0;
		
		for(EObject trackPiece : tracks){
			
			// Find out what type of track we are dealing with
			path = path + switch trackPiece {
		
				// Straight Track
				Straight: {
					println("Straight Piece of Track");
					println(currentAngle);
					
					// Calculate the end position
					val length = trackPiece.length;
					
					// Project in the current direction
					val endX = Math.sin(Math.toRadians(currentAngle)) *  length;
					val endY = Math.cos(Math.toRadians(currentAngle)) *  length;
					
					" l " + endX + " " +endY;
					
				}
				
				Corner: {
				
				// For now with all corners we are going to fix arc size at 100.
				val arcSize = " 100 100 ";
				
				// -1 for anticlockwise and 1 for clockwise
				val modifier = switch trackPiece.direction {
					case 'left': -1 
					case 'right': 1
				};
				
				val flags = switch trackPiece.direction {
					case 'left':  " 0 0 1 "
					case 'right': " 0 0 0 "
				}

				var x = 0;
				var y = 0;
				var angle = 0.0;
				
				// Work out the distances
				switch trackPiece.type {
					case 'sharp45': {
						x = 25;
						y = 50;
						angle = 22.5;
					} case 'sharp90': {
						x = 50;
						y = 50;
						angle = 45;
					} case 'easy45': {
						x = 50;
						y = 100;
						angle = 22.5;
					} case 'easy90': {
						x = 100;
						y = 100;
						angle = 45;
					}
				}
				
				println(trackPiece.type + ", X:" + x + ", Y:" + y + ", A "+angle);
				
				// Rotate end points around the current angle, modifier controls the direction
				val endX = Math.sin(Math.toRadians(modifier * (angle + currentAngle))) *  Math.sqrt(x * x + y * y);
				val endY = Math.cos(Math.toRadians(modifier * (angle + currentAngle))) *  Math.sqrt(x * x + y * y);
				
				println("End X:" + endX + ", EndY:" + endY);
				
				// Set the new angle
				currentAngle = currentAngle + (angle * 2 * modifier);
				
				println("Corner");
				
				var arc = " a " + arcSize + " "+ flags + " " + endX + " " + endY + " ";
				println(arc);
				arc;

				}
				
			}

		}

		val pathEnd = '''"stroke="black" fill="transparent"/>'''
		
		// Closing of the path tag			
		var end = '''</svg>'''
		
		// Build the path with enclosing svg 
		start + pathStart + path + pathEnd + end;
		
	}
}
	
	

//	/**
//	 * Example to generate a java program to print all the tracks
//	 */
//	def compile (Iterable <Track> tracks) 
//	
//	''' 
//	public class Track { 
//	
//	String name,corner,slope;
//	
//	public Track (String name, String corner) {
//	this.name = name;
//	this.corner = corner;
//	}
//	
//	public String toString (){
//		return "I am a track with the name"+ this.name + ", with a corner of " +this.corner;
//	}
//	
//	public static void main(String[]args){
//		
//		Track t = null;
//		
//«FOR t:tracks»
// 	t = new Track("«t.name»" «IF t.angle != null» "«t.angle»" «ELSE» "NO ANGLE" «ENDIF»);
// 	System.out.println(t);
//«ENDFOR»
//  		
//  		System.out.println("Thoes are all the tracks");
//	}
//}
//	'''
//}

