/**
 * generated by Xtext
 */
package org.xtext.rollercoaster.dsl.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.xtext.rollercoaster.dsl.coaster.CoasterPackage.Literals;
import org.xtext.rollercoaster.dsl.coaster.Corner;
import org.xtext.rollercoaster.dsl.coaster.RollerCoaster;
import org.xtext.rollercoaster.dsl.coaster.SignedInt;
import org.xtext.rollercoaster.dsl.coaster.Straight;
import org.xtext.rollercoaster.dsl.validation.AbstractCoasterValidator;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class CoasterValidator extends AbstractCoasterValidator {
  @Check
  public String checkCompletePath(final RollerCoaster rc) {
    String _xblockexpression = null;
    {
      int totalAngle = 0;
      EList<EObject> _track = rc.getTrack();
      Iterable<Corner> _filter = Iterables.<Corner>filter(_track, Corner.class);
      for (final Corner t : _filter) {
        {
          int dir = 1;
          String _direction = t.getDirection();
          boolean _equals = _direction.equals("left");
          if (_equals) {
            int _minus = (-1);
            dir = _minus;
          }
          boolean _or = false;
          String _type = t.getType();
          boolean _equals_1 = _type.equals("sharp45");
          if (_equals_1) {
            _or = true;
          } else {
            String _type_1 = t.getType();
            boolean _equals_2 = _type_1.equals("easy45");
            _or = (_equals_1 || _equals_2);
          }
          if (_or) {
            int _multiply = (45 * dir);
            int _plus = (totalAngle + _multiply);
            totalAngle = _plus;
          } else {
            int _multiply_1 = (90 * dir);
            int _plus_1 = (totalAngle + _multiply_1);
            totalAngle = _plus_1;
          }
        }
      }
      int _modulo = (totalAngle % 360);
      boolean _notEquals = (_modulo != 0);
      if (_notEquals) {
        int _modulo_1 = (totalAngle % 360);
        String _plus = ("Track angles do not form a cycle! " + Integer.valueOf(_modulo_1));
        String _plus_1 = (_plus + " degrees from a cycle.");
        EStructuralFeature _eStructuralFeature = Literals.ROLLER_COASTER.getEStructuralFeature("track");
        this.warning(_plus_1, _eStructuralFeature);
      }
      String _plus_2 = ("totalAngle = " + Integer.valueOf(totalAngle));
      String _println = InputOutput.<String>println(_plus_2);
      _xblockexpression = (_println);
    }
    return _xblockexpression;
  }
  
  @Check
  public void checkStartMeetsEnd(final RollerCoaster rc) {
    double distance = 0.0;
    double currentX = 0.0;
    double currentY = 0.0;
    double currentAngle = 0.0;
    EList<EObject> _track = rc.getTrack();
    for (final Object t : _track) {
      {
        Corner c = null;
        Straight s = null;
        boolean _matched = false;
        if (!_matched) {
          if (t instanceof Corner) {
            final Corner _corner = (Corner)t;
            _matched=true;
            c = _corner;
          }
        }
        if (!_matched) {
          if (t instanceof Straight) {
            final Straight _straight = (Straight)t;
            _matched=true;
            s = _straight;
          }
        }
        boolean _notEquals = (!Objects.equal(c, null));
        if (_notEquals) {
          double dir = 1.0;
          double angle = 0.0;
          String _direction = c.getDirection();
          boolean _equals = _direction.equals("left");
          if (_equals) {
            int _minus = (-1);
            dir = _minus;
          }
          boolean _or = false;
          String _type = c.getType();
          boolean _equals_1 = _type.equals("sharp45");
          if (_equals_1) {
            _or = true;
          } else {
            String _type_1 = c.getType();
            boolean _equals_2 = _type_1.equals("easy45");
            _or = (_equals_1 || _equals_2);
          }
          if (_or) {
            double _multiply = (22.5 * dir);
            double _radians = Math.toRadians(_multiply);
            angle = _radians;
          } else {
            double _multiply_1 = (45 * dir);
            double _radians_1 = Math.toRadians(_multiply_1);
            angle = _radians_1;
          }
          int r = rc.getTrackUnitLength();
          String _type_2 = c.getType();
          boolean _equals_3 = _type_2.equals("sharp45");
          if (_equals_3) {
            double _plus = (currentAngle + angle);
            double _cos = Math.cos(_plus);
            double _divide = (r / 2.0);
            double _pow = Math.pow(_divide, 2);
            double _pow_1 = Math.pow(r, 2);
            double _plus_1 = (_pow + _pow_1);
            double _sqrt = Math.sqrt(_plus_1);
            double _multiply_2 = (_cos * _sqrt);
            double _plus_2 = (currentX + _multiply_2);
            currentX = _plus_2;
            double _plus_3 = (currentAngle + angle);
            double _sin = Math.sin(_plus_3);
            double _divide_1 = (r / 2.0);
            double _pow_2 = Math.pow(_divide_1, 2);
            double _pow_3 = Math.pow(r, 2);
            double _plus_4 = (_pow_2 + _pow_3);
            double _sqrt_1 = Math.sqrt(_plus_4);
            double _multiply_3 = (_sin * _sqrt_1);
            double _plus_5 = (currentY + _multiply_3);
            currentY = _plus_5;
          } else {
            String _type_3 = c.getType();
            boolean _equals_4 = _type_3.equals("sharp90");
            if (_equals_4) {
              double _plus_6 = (currentAngle + angle);
              double _cos_1 = Math.cos(_plus_6);
              double _divide_2 = (r / 2.0);
              double _pow_4 = Math.pow(_divide_2, 2);
              double _divide_3 = (r / 2.0);
              double _pow_5 = Math.pow(_divide_3, 2);
              double _plus_7 = (_pow_4 + _pow_5);
              double _sqrt_2 = Math.sqrt(_plus_7);
              double _multiply_4 = (_cos_1 * _sqrt_2);
              double _plus_8 = (currentX + _multiply_4);
              currentX = _plus_8;
              double _plus_9 = (currentAngle + angle);
              double _sin_1 = Math.sin(_plus_9);
              double _divide_4 = (r / 2.0);
              double _pow_6 = Math.pow(_divide_4, 2);
              double _divide_5 = (r / 2.0);
              double _pow_7 = Math.pow(_divide_5, 2);
              double _plus_10 = (_pow_6 + _pow_7);
              double _sqrt_3 = Math.sqrt(_plus_10);
              double _multiply_5 = (_sin_1 * _sqrt_3);
              double _plus_11 = (currentY + _multiply_5);
              currentY = _plus_11;
            } else {
              String _type_4 = c.getType();
              boolean _equals_5 = _type_4.equals("easy45");
              if (_equals_5) {
                double _plus_12 = (currentAngle + angle);
                double _cos_2 = Math.cos(_plus_12);
                double _pow_8 = Math.pow(r, 2);
                int _multiply_6 = (r * 2);
                double _pow_9 = Math.pow(_multiply_6, 2);
                double _plus_13 = (_pow_8 + _pow_9);
                double _sqrt_4 = Math.sqrt(_plus_13);
                double _multiply_7 = (_cos_2 * _sqrt_4);
                double _plus_14 = (currentX + _multiply_7);
                currentX = _plus_14;
                double _plus_15 = (currentAngle + angle);
                double _sin_2 = Math.sin(_plus_15);
                double _pow_10 = Math.pow(r, 2);
                int _multiply_8 = (r * 2);
                double _pow_11 = Math.pow(_multiply_8, 2);
                double _plus_16 = (_pow_10 + _pow_11);
                double _sqrt_5 = Math.sqrt(_plus_16);
                double _multiply_9 = (_sin_2 * _sqrt_5);
                double _plus_17 = (currentY + _multiply_9);
                currentY = _plus_17;
              } else {
                String _type_5 = c.getType();
                boolean _equals_6 = _type_5.equals("easy90");
                if (_equals_6) {
                  double _plus_18 = (currentAngle + angle);
                  double _cos_3 = Math.cos(_plus_18);
                  double _pow_12 = Math.pow(r, 2);
                  double _pow_13 = Math.pow(r, 2);
                  double _plus_19 = (_pow_12 + _pow_13);
                  double _sqrt_6 = Math.sqrt(_plus_19);
                  double _multiply_10 = (_cos_3 * _sqrt_6);
                  double _plus_20 = (currentX + _multiply_10);
                  currentX = _plus_20;
                  double _plus_21 = (currentAngle + angle);
                  double _sin_3 = Math.sin(_plus_21);
                  double _pow_14 = Math.pow(r, 2);
                  double _pow_15 = Math.pow(r, 2);
                  double _plus_22 = (_pow_14 + _pow_15);
                  double _sqrt_7 = Math.sqrt(_plus_22);
                  double _multiply_11 = (_sin_3 * _sqrt_7);
                  double _plus_23 = (currentY + _multiply_11);
                  currentY = _plus_23;
                }
              }
            }
          }
          double _multiply_12 = (angle * 2);
          double _plus_24 = (currentAngle + _multiply_12);
          currentAngle = _plus_24;
        } else {
          boolean _notEquals_1 = (!Objects.equal(s, null));
          if (_notEquals_1) {
            double _cos_4 = Math.cos(currentAngle);
            int _length = s.getLength();
            double _multiply_13 = (_cos_4 * _length);
            double _plus_25 = (currentX + _multiply_13);
            currentX = _plus_25;
            double _sin_4 = Math.sin(currentAngle);
            int _length_1 = s.getLength();
            double _multiply_14 = (_sin_4 * _length_1);
            double _plus_26 = (currentY + _multiply_14);
            currentY = _plus_26;
          }
        }
      }
    }
    double _pow = Math.pow(currentX, 2);
    double _pow_1 = Math.pow(currentY, 2);
    double _plus = (_pow + _pow_1);
    double _sqrt = Math.sqrt(_plus);
    distance = _sqrt;
    boolean _greaterEqualsThan = (distance >= 0.5);
    if (_greaterEqualsThan) {
      int _intValue = Double.valueOf(distance).intValue();
      int _plus_1 = (_intValue + 1);
      String _plus_2 = ("End of Track does not meet start! End of track is" + Integer.valueOf(_plus_1));
      String _plus_3 = (_plus_2 + "m from the start.");
      EStructuralFeature _eStructuralFeature = Literals.ROLLER_COASTER.getEStructuralFeature("track");
      this.warning(_plus_3, _eStructuralFeature);
    }
  }
  
  @Check
  public void elevationMeetsAtStartAndEnd(final RollerCoaster rc) {
    int elevation = 0;
    EList<EObject> _track = rc.getTrack();
    for (final Object t : _track) {
      {
        Corner c = null;
        Straight s = null;
        boolean _matched = false;
        if (!_matched) {
          if (t instanceof Corner) {
            final Corner _corner = (Corner)t;
            _matched=true;
            c = _corner;
          }
        }
        if (!_matched) {
          if (t instanceof Straight) {
            final Straight _straight = (Straight)t;
            _matched=true;
            s = _straight;
          }
        }
        boolean _notEquals = (!Objects.equal(s, null));
        if (_notEquals) {
          SignedInt _elevationChange = s.getElevationChange();
          int change = _elevationChange.getValue();
          SignedInt _elevationChange_1 = s.getElevationChange();
          String _sign = _elevationChange_1.getSign();
          boolean _notEquals_1 = (!Objects.equal(_sign, null));
          if (_notEquals_1) {
            int _minus = (-1);
            int _multiply = (change * _minus);
            change = _multiply;
          }
          int _plus = (elevation + change);
          elevation = _plus;
        }
      }
    }
    boolean _notEquals = (elevation != 0);
    if (_notEquals) {
      String _plus = ("End of Track does not meet start! Height of last track unit is " + Integer.valueOf(elevation));
      String _plus_1 = (_plus + "m from start.");
      EStructuralFeature _eStructuralFeature = Literals.ROLLER_COASTER.getEStructuralFeature("track");
      this.warning(_plus_1, _eStructuralFeature);
    }
  }
  
  @Check
  public void hasEnoughPower(final RollerCoaster rc) {
    int speed = 0;
    EList<EObject> _track = rc.getTrack();
    for (final Object t : _track) {
      {
        Corner c = null;
        Straight s = null;
        boolean _matched = false;
        if (!_matched) {
          if (t instanceof Corner) {
            final Corner _corner = (Corner)t;
            _matched=true;
            c = _corner;
          }
        }
        if (!_matched) {
          if (t instanceof Straight) {
            final Straight _straight = (Straight)t;
            _matched=true;
            s = _straight;
          }
        }
        boolean _notEquals = (!Objects.equal(s, null));
        if (_notEquals) {
          String _powered = s.getPowered();
          boolean _notEquals_1 = (!Objects.equal(_powered, null));
          if (_notEquals_1) {
            int _length = s.getLength();
            int _multiply = (_length * 2);
            int _plus = (speed + _multiply);
            speed = _plus;
          }
          SignedInt _elevationChange = s.getElevationChange();
          boolean _notEquals_2 = (!Objects.equal(_elevationChange, null));
          if (_notEquals_2) {
            SignedInt _elevationChange_1 = s.getElevationChange();
            int change = _elevationChange_1.getValue();
            SignedInt _elevationChange_2 = s.getElevationChange();
            String _sign = _elevationChange_2.getSign();
            boolean _notEquals_3 = (!Objects.equal(_sign, null));
            if (_notEquals_3) {
              int _minus = (-1);
              int _multiply_1 = (change * _minus);
              change = _multiply_1;
            }
            boolean _notEquals_4 = (change != 0);
            if (_notEquals_4) {
              int _length_1 = s.getLength();
              int _multiply_2 = (change * _length_1);
              int _plus_1 = (speed + _multiply_2);
              speed = _plus_1;
            }
          } else {
            int _length_2 = s.getLength();
            int _divide = (_length_2 / 2);
            int _minus_1 = (speed - _divide);
            speed = _minus_1;
          }
          InputOutput.<Integer>println(Integer.valueOf(speed));
          boolean _lessEqualsThan = (speed <= 0);
          if (_lessEqualsThan) {
            String _name = s.getName();
            String _plus_2 = ("Cart is moving backwards or stopped on " + _name);
            String _plus_3 = (_plus_2 + ", add powered units or downhill slopes.");
            EStructuralFeature _eStructuralFeature = Literals.ROLLER_COASTER.getEStructuralFeature("track");
            this.warning(_plus_3, _eStructuralFeature);
          }
        }
      }
    }
  }
}
